namespace WebChemistry.Charges.Service
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using WebChemistry.Platform.Services;
    using WebChemistry.Charges.Service.DataModel;
    using WebChemistry.Charges.Core;
    using WebChemistry.Framework.Core;
    using System.Xml.Linq;
    using WebChemistry.Platform;
    using System.IO;
    using System.Diagnostics;

    class ChargesService : ServiceBase<ChargesService, ChargesServiceConfig, ChargesServiceStandaloneConfig, ChargesService.CustomProgress>
    {
        public override AppVersion GetVersion()
        {
            return new AppVersion(1, 0, 23, 12, 27, 'b');
        }

        public override string GetName()
        {
            return "Charges";
        }

        public string GeneratedByRemark()
        {
            return string.Format("Generated by WebChemistry Charges ({0}), {1}", GetVersion(), DateTime.UtcNow);
        }

        public class CustomProgress
        {
            public int CurrentProgress { get; set; }
            public int MaxProgress { get; set; }
            public bool IsIndeterminate { get; set; }
            public string Message { get; set; }

            public int CurrentSetProgress { get; set; }
            public int CurrentSetMaxProgress { get; set; }
            public bool IsCurrentSetProgressAvailable { get; set; }
        }

        Stopwatch ComputationTimer;

        ServiceInputProvider Input;
        ChargeServiceExporter Exporter;
        
        ParameterSetManager ParameterSets;
        ChargesServiceConfigBase Config;

        List<string> GeneralErrors, GeneralWarnings;

        List<ChargesServiceComputationEntrySummary> ResultSummaryEntries;

        Dictionary<string, double[]> TotalCharges;

        int JobCount, CurrentJobIndex;

        TimeSpan EstimateRemaining(ComputationProgress progress, Stopwatch sw)
        {
            return TimeSpan.FromTicks((long)(((double)progress.Length / progress.Current - 1.0) * (double)sw.ElapsedTicks));
        }

        ChargeComputationResultWrapper ComputeSet(EemChargeComputationParameters prms)
        {
            Log("Computing {0}...", prms.Id);

            if (prms.Method == ChargeComputationMethod.Eem) Environment.SetEnvironmentVariable("OMP_NUM_THREADS", Config.MaxDegreeOfParallelism.ToString());
            else Environment.SetEnvironmentVariable("OMP_NUM_THREADS", "1");
            
            var progress = new ComputationProgress();
            var sw = new Stopwatch();
            var lastUpdated = TimeSpan.FromTicks(0);
            var lastUpdatedCurrent = 0;

            if (prms.Method != ChargeComputationMethod.Eem)
            {
                CustomState.IsCurrentSetProgressAvailable = false;
                progress.PropertyChanged += (s, a) =>
                {
                    if (progress.IsIndeterminate || progress.Current == lastUpdatedCurrent) return;

                    var el = sw.Elapsed;
                    var delta = el - lastUpdated;
                    if (delta.TotalSeconds >= 0.5)
                    {
                        lastUpdated = el;
                        lastUpdatedCurrent = progress.Current;
                        CustomState.IsCurrentSetProgressAvailable = true;
                        CustomState.CurrentSetMaxProgress = progress.Length;
                        CustomState.CurrentSetProgress = progress.Current;
                        UpdateStatus();
                        Console.Write("\rProgress: {0}/{1} ({2:0.00}%), elapsed: {3}".PadRight(76),
                            progress.Current, progress.Length,
                            100.0 * (double)progress.Current / progress.Length,
                            Helpers.GetTimeString(sw.Elapsed));
                            //, Helpers.GetTimeString(EstimateRemaining(progress, sw)));
                    }
                };
            }
            else
            {
                CustomState.IsCurrentSetProgressAvailable = false;
                Console.Write("Progress: Indeterminate.");
            }

            sw.Start();
            var result = EemSolver.Compute(prms, progress);
            sw.Stop();

            Console.Write("\r{0}", new String(' ', Console.BufferWidth - 2));
            Console.Write("\r");

            return new ChargeComputationResultWrapper(sw.Elapsed, result);
        }

        ChargesCorrelationEntry Correlate(ChargeComputationResult ra, AtomPartitionCharges a, ChargeComputationResult rb, AtomPartitionCharges b)
        {
            return ChargeStatistics.FitData(ra.Parameters.Id, a, rb.Parameters.Id, b);
        }

        ExporterStructureDataEntry AnalyzeAndExportResult(IStructure structure, AtomPartition[] partitions, List<ChargeComputationResultWrapper> results)
        {
            // Export the raw charges.
            Exporter.ExportStructure(new ExporterStructureEntry { Structure = structure, Charges = results });

            var partitionResults = new List<AtomPartitionResultWrapper>();

            // Compute the partitions.
            foreach (var partition in partitions)
            {
                var toExport = new List<Tuple<ChargeComputationResultWrapper, AtomPartitionCharges>>();

                foreach (var result in results)
                {
                    if (result.Result.State == ChargeResultState.Error) continue;
                    var charges = partition.GetGroupCharges(result.Result);
                    toExport.Add(Tuple.Create(result, charges));
                }

                toExport = toExport.OrderBy(c => c.Item1.Result.Parameters.Id).ToList();

                // Compute the correlations.
                Dictionary<string, Dictionary<string, ChargesCorrelationEntry>> correlations = new Dictionary<string, Dictionary<string, ChargesCorrelationEntry>>();                
                for (int i = 0; i < toExport.Count - 1; i++)
                {
                    var a = toExport[i];
                    Dictionary<string, ChargesCorrelationEntry> inner = new Dictionary<string, ChargesCorrelationEntry>();
                    correlations[a.Item1.Result.Parameters.Id] = inner;
                    for (int j = i + 1; j < toExport.Count; j++)
                    {
                        var b = toExport[j];
                        inner[b.Item1.Result.Parameters.Id] = Correlate(a.Item1.Result, a.Item2, b.Item1.Result, b.Item2);
                    }
                }

                var pcs = toExport.Select(e => e.Item2).ToArray();

                // Export the partition.                
                Exporter.ExportPartition(new ExporterPartitionEntry
                {
                    Structure = structure,
                    Partition = partition,
                    PartitionCharges = pcs,
                    Correlations = correlations
                });

                partitionResults.Add(new AtomPartitionResultWrapper
                {
                    Partition = partition,
                    Correlations = correlations,
                    PartitionCharges = pcs
                });
            }

            return new ExporterStructureDataEntry
            {
                Structure = structure,
                Partitions = partitionResults,
                Charges = results
            };
        }

        ChargesServiceComputationEntrySummary ProcessEntry(ServiceInputEntryProvider entry)
        {
            var structureTimer = Stopwatch.StartNew();
            try
            {
                Log("Processing {0}...", entry.StructureFilenameId);
                CustomState.IsIndeterminate = true;
                CustomState.Message = "Reading structure...";
                UpdateProgress(string.Format("Computing {0}...", entry.StructureFilenameId), ++CurrentJobIndex, JobCount);

                var sr = StructureReader.Read(entry.Filename, entry.StreamProvider);
                var structure = sr.Structure;
                var partitions = DefaultParititionDescriptors.MakePartitions(structure);
                var warnings = new List<string>();
                var errors = new List<string>();

                if (structure.Atoms.Count(a => a.ElementSymbol == ElementSymbols.H) == 0)
                {
                    warnings.Add("The structure is missing hydrogen atoms. Is this intended?");
                }

                var rawResults = new List<ChargeComputationResultWrapper>();
                var refs = Input.GetPrefixEntries(entry.StructureFilenameId + "_ref_").Where(e => ChargeServiceUtils.IsReferenceChargesFilename(e.Filename)).ToArray();

                CustomState.Message = "Reading reference charges...";
                UpdateStatus();
                // do the reference charges.
                foreach (var rc in refs)
                {
                    try
                    {
                        var timer = Stopwatch.StartNew();
                        var result = ChargeComputationResult.FromReference(rc.Filename, structure, rc.StreamProvider);
                        timer.Stop();
                        rawResults.Add(new ChargeComputationResultWrapper(timer.Elapsed, result));
                    }
                    catch (Exception ex)
                    {
                        var msg = Log("Error reading reference charges '{0}': {1}", rc.Filename, ex.Message);
                        errors.Add(msg);
                    }
                }

                if (structure.Mol2ContainsCharges())
                {
                    var timer = Stopwatch.StartNew();
                    var result = ChargeComputationResult.FromProperty(structure, "mol2", a => a.Mol2PartialCharge());
                    timer.Stop();
                    rawResults.Add(new ChargeComputationResultWrapper(timer.Elapsed, result));
                }
                else if (structure.PqrContainsCharges())
                {
                    var timer = Stopwatch.StartNew();
                    var result = ChargeComputationResult.FromProperty(structure, "pqr", a => a.PqrCharge());
                    timer.Stop();
                    rawResults.Add(new ChargeComputationResultWrapper(timer.Elapsed, result));
                }
                
                double[] totalCharges = this.TotalCharges[structure.Id].Distinct().ToArray();
                if (totalCharges.Length == 0)
                {
                    totalCharges = new double[] { 0.0 };
                    warnings.Add("Total charge not specified, using the default value 0.");
                }

                CustomState.IsIndeterminate = false;
                CustomState.CurrentProgress = 0;
                CustomState.MaxProgress = Config.Sets.Length * totalCharges.Length;
                foreach (var set in Config.Sets)
                {
                    foreach (var tc in totalCharges)
                    {                        
                        CustomState.CurrentProgress++;
                        var prms = set.ToComputationParameters(structure, tc, ParameterSets);
                        CustomState.Message = string.Format("Computing {0}...", prms.Id);
                        UpdateStatus();
                        try
                        {
                            var resultWrapper = ComputeSet(prms);
                            var result = resultWrapper.Result;

                            if (result.Charges.Count == 0)
                            {
                                throw new InvalidOperationException("The parameter set does not contain parameters for any of the molecule's atoms.");
                            }

                            if (result.State == ChargeResultState.Warning) warnings.AddRange(result.Messages.Select(w => prms.Id + ": " + w));
                            else if (result.State == ChargeResultState.Error)
                            {
                                Log("Error [{0}, {1}]: {2}", structure.Id, prms.Id, string.Join("; ", result.Messages));
                                errors.AddRange(result.Messages.Select(err => prms.Id + ": " + err));
                            }

                            rawResults.Add(resultWrapper);
                        }
                        catch (Exception ex)
                        {
                            var msg = Log("Error computing '{0}' with total charge '{1}': {2}", prms.Id, tc.ToStringInvariant(), ex.Message);
                            errors.Add(msg);
                        }
                        UpdateStatus();
                    }
                }

                CustomState.IsIndeterminate = true;
                CustomState.Message = "Analyzing and exporting results...";
                Log("Analyzing and exporting {0}...", structure.Id);
                var data = AnalyzeAndExportResult(structure, partitions, rawResults);

                structureTimer.Stop();
                var resultEntry = new ChargesServiceComputationEntrySummary
                {
                    Id = structure.Id,
                    IsValid = true,
                    TimingMs = structureTimer.ElapsedMilliseconds,
                    AtomCounts = structure.Atoms.GroupBy(a => a.ElementSymbol).ToDictionary(g => g.Key.ToString(), g => g.Count(), StringComparer.Ordinal),
                    ReaderWarnings = sr.Warnings.Select(w => w.ToString()).ToArray(),
                    ComputationWarnings = warnings.ToArray(),
                    Errors = errors.ToArray()
                };

                data.Summary = resultEntry;
                Exporter.ExportStructureData(data);

                return resultEntry;
            }
            catch (Exception e)
            {
                structureTimer.Stop();
                Log("Error processing '{0}': {1}", e.Message, entry.StructureFilenameId);
                var resultEntry = new ChargesServiceComputationEntrySummary
                {
                    Id = StructureReader.GetStructureIdFromFilename(entry.Filename),
                    IsValid = false,
                    TimingMs = structureTimer.ElapsedMilliseconds,
                    Errors = new[] { e.Message }
                };

                var data = new ExporterStructureDataEntry
                {
                    Summary = resultEntry
                };

                Exporter.ExportStructureData(data);

                return resultEntry;
            }
        }

        List<EemParameterSet> ReadSets()
        {
            try
            {
                ParameterSets = new ParameterSetManager();
                if (IsStandalone)
                {
                    XElement xml = XElement.Load(StandaloneSettings.SetsXmlFilename);
                    ParameterSets.Update(xml);
                }
                else
                {
                    foreach (var xml in Settings.SetsXml)
                    {
                        var set = EemParameterSet.FromXml(XElement.Parse(xml));
                        ParameterSets.Update(set);
                    }
                }
            }
            catch (Exception e)
            {
                throw new InvalidOperationException(string.Format("Error reading parameter sets: {0}", e.Message));
            }

            List<EemParameterSet> ret = new List<EemParameterSet>();
            foreach (var set in Config.Sets)
            {
                var s = ParameterSets.GetByName(set.Name);
                if (s == null)
                {
                    throw new InvalidOperationException(string.Format("Cannot find parameter set named '{0}'.", set.Name));
                }
                ret.Add(s);
            }
            return ret;
        }

        void ComputeInternal()
        {
            Log("Initializing...");
            UpdateProgress("Initializing...");

            var jobIds = Config.Jobs.Select(j => j.Id).ToHashSet(StringComparer.OrdinalIgnoreCase);
            if (jobIds.Count != Config.Jobs.Length)
            {
                throw new InvalidOperationException("Each job must have a unique identifier (correspond to a single unique structure).");
            }

            this.TotalCharges = Config.Jobs.ToDictionary(j => j.Id, j => j.TotalCharges, StringComparer.OrdinalIgnoreCase);

            GeneralErrors = new List<string>();
            GeneralWarnings = new List<string>();
            ResultSummaryEntries = new List<ChargesServiceComputationEntrySummary>();

            MathNet.Numerics.Control.LinearAlgebraProvider = new MathNet.Numerics.Algorithms.LinearAlgebra.Mkl.MklLinearAlgebraProvider();
            EemSolver.MaxDegreeOfParallelism = Config.MaxDegreeOfParallelism;
            EemSolver.MaxFullEemProblemSize = Config.MaxFullEemAtomCount;

            var inputSets = ReadSets();

            HashSet<string> visitedEntries = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            HashSet<string> processedEntries = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            
            using (Input = IsStandalone
                ? ServiceInputProvider.FromFolder(StandaloneSettings.InputFolder)
                : ServiceInputProvider.FromZip(ChargeCalculatorApp.GetInputZipFilename(this.Computation)))
            {

                var structureEntries = Input.GetStructureEntries();                    
                
                //Config.TotalCharges.ToDictionary(e => e.Key, e => e.Value, StringComparer.OrdinalIgnoreCase);
                JobCount = Config.Jobs.Length; //structureEntries.Count;

                using (Exporter = new ChargeServiceExporter(this, ResultFolder, IsStandalone ? StandaloneSettings.ExportUncompressed : false, 
                    Computation != null ? Computation.DateCreated : DateTimeService.GetCurrentTime()))
                {
                    foreach (var e in structureEntries)
                    {
                        var id = StructureReader.GetStructureIdFromFilename(e.Filename);
                        if (!visitedEntries.Add(id))
                        {
                            GeneralWarnings.Add(Log("Structure with id '{0}' was already processed.", e.StructureFilenameId));
                            continue;
                        }

                        if (!jobIds.Contains(id))
                        {
                            //GeneralWarnings.Add(Log("Job entry for '{0}' was not found, skipping.", e.FilenameWithoutExtension));
                            continue;
                        }

                        var result = ProcessEntry(e);
                        ResultSummaryEntries.Add(result);
                        processedEntries.Add(id);
                    }

                    if (processedEntries.Count < jobIds.Count)
                    {
                        GeneralWarnings.Add(Log("There was no structure found for job(s) '{0}'.", string.Join(", ", jobIds.Where(j => !visitedEntries.Contains(j)).OrderBy(j => j))));
                    }

                    var summary = new ChargesServiceComputationSummary
                    {
                        Entries = ResultSummaryEntries.ToArray(),
                        Version = GetVersion().ToString(),
                        Errors = GeneralErrors.ToArray(),
                        Warnings = GeneralWarnings.ToArray(),
                        TimingMs = ComputationTimer.ElapsedMilliseconds
                    };

                    Exporter.ExportSummary(summary);
                    Exporter.ExportParameterSets(inputSets.OrderBy(s => s.Name).ToArray());
                }
            }
        }
        
        void Compute()
        {
            try
            {
                ComputationTimer = Stopwatch.StartNew();
                ComputeInternal();
                Log("Done in {0}.", ComputationTimer.Elapsed);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
                var summary = new ChargesServiceComputationSummary
                {
                    Version = GetVersion().ToString(),
                    TimingMs = ComputationTimer.ElapsedMilliseconds,
                    Errors = new [] { "Fatal Error: " + e.Message }
                };
                JsonHelper.WriteJsonFile(Path.Combine(ResultFolder, "summary.json"), summary);
            }
            finally
            {
                ComputationTimer.Stop();
            }
        }

        protected override void RunHostedInternal()
        {
            Config = Settings;
            Compute();
        }

        protected override void RunStandaloneInternal()
        {
            Config = StandaloneSettings;
            Compute();
        }

        public override void UpdateHelpConfig(ServiceHelpConfig config)
        {
            config.RunningRemarks = new [] {
                "In Linux and  MacOS, specific version of the Intel MKL library must be provided in order for the computation to run fast. See http://numerics.mathdotnet.com/ for more info."
            };

            config.OutputStructure
                .AddSpecificFileStructure(
                    HelpOutputSpecificFileDescription.Generic("json folder", "JSON files from this folder can be deserialized to the type `WebChemistry.Charges.Service.DataModel.ChargesServiceStructureData` available in the .NET library WebChemistry.Charges.Service.DataModel.dll included with the program."));
        }

        protected override HelpOutputStructureDescription MakeOutputStructure()
        {
            return HelpFolder("result", "Folder with computation result.",                      
                HelpFolder("charges", "Folder with computed charges",
                    HelpFolder("<source>", "A folder for each charge source",
                        HelpFolder("mol2", "Folder with structures in MOL2 format"),
                        HelpFolder("pqr", "Folder with structures in PQR format"),
                        HelpFolder("wprop", "Folder with results in WPROP format - a list of pairs of atom serial numbers and values of atomic charges <Atom Id> <Charge>"),
                        HelpFolder("computation_setup.json", "File describing the setup of the calculation")),
                    HelpFile("<molecule>_allcharges.csv", "CSV file for each molecule with all computed charges")),
                HelpFolder("statistics", "Folder with statistics about the computed charges",
                    HelpFolder("Atoms", "Statistics data for each molecule, calculated at atomic level resolution",
                        HelpFolder("mol2", "Folder with structures in MOL2 format"),
                        HelpFolder("csv", "Folder - for each molecule, a CSV file with all computed atomic charges"),
                        HelpFolder("correlations", "Folder - for each molecule, a CSV file with correlation statistics between all computed atomic charges"),
                        HelpFolder("properties", "Folder with statistics based on several specific properties of atoms")),
                    HelpFolder("Residues", "Statistics data for each molecule, calculated at the residue level resolution - only present if the input file contained relevant residue information",
                        HelpFolder("mol2", "Folder with mock structures in MOL2 format, where each atom represents a single residue"),
                        HelpFolder("csv", "Folder - for each molecule, a CSV file with all computed residue charges"),
                        HelpFolder("correlations", "Folder - for each molecule, a CSV file with correlation statistics between all computed residue charges"),
                        HelpFolder("properties", "Folder with statistics based on several specific properties of residues"))),
                HelpFolder("json", "All data for each molecule in JSON format",
                    HelpFile("<molecule>.json", "Entry for each molecule")),
                HelpFolder("logs", "Folder with computation logs",
                    HelpFile("<molecule>_log.csv ", "A log entry for each molecule that includes execution time, warnings, etc.")),
                HelpFile("Sets.xml", "Parameter sets used for the computation"),
                HelpFile("Summary_<date:year-month-day>_<time:hour-minute>.json", "Summary information about the entire computation, date/time is in universal time"));
        }
        
        protected override ChargesServiceStandaloneConfig SampleStandaloneSettings()
        {
            return new ChargesServiceStandaloneConfig
            {
                InputFolder = "c:\\Data\\Structures",
                SetsXmlFilename = "c:\\Data\\DefaultSets.xml",
                Sets = new [] { 
                    new ChargeSetConfig
                    {
                        Name = "RS2-EX",
                        Method = Core.ChargeComputationMethod.EemCutoffCover,
                        CutoffRadius = 13.0,
                        Precision = Core.ChargeComputationPrecision.Double,
                        CorrectCutoffTotalCharge = true
                    },
                    new ChargeSetConfig
                    {
                        Name = "RS2-E",
                        Method = Core.ChargeComputationMethod.Eem,
                        Precision = Core.ChargeComputationPrecision.Double
                    }
                },
                Jobs = new[]
                {
                    new ChargesServiceJob { Id = "1tqn", TotalCharges = new [] { -6.0 } },
                    new ChargesServiceJob { Id = "1e12", TotalCharges = new [] { 60.0 } }
                },
            };
        }
    }
}
