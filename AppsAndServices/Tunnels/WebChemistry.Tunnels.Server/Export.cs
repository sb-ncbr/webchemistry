/*
 * Copyright (c) 2016 David Sehnal, licensed under MIT license, See LICENSE file for more info.
 */

namespace WebChemistry.Tunnels.Server
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.IO.Compression;
    using System.Linq;
    using System.Text;
    using System.Xml;
    using System.Xml.Linq;
    using WebChemistry.Framework.Core;
    using WebChemistry.Framework.Math;
    using WebChemistry.Tunnels.Core;
    using WebChemistry.Tunnels.Core.Export;
    using WebChemistry.Tunnels.Core.Helpers;

    class ExportParameters
    {
        public bool FormatMesh { get; set; }
        public bool FormatMeshGz { get; set; }
        public bool FormatPyMol { get; set; }
        public bool FormatChimera { get; set; }
        public bool FormatVMD { get; set; }
        public bool FormatPdbProfile { get; set; }
        public bool FormatPdbStructure { get; set; }
        public bool FormatCSV { get; set; }
        public bool FormatJSON { get; set; }
        public bool FormatChargeSurface { get; set; }
        
        public bool ExportCavities { get; set; }
        public bool ExportMergedPores { get; set; }
        public bool ExportUserPores { get; set; }
        public bool ExportAutoPores { get; set; }
        public bool ExportTunnels { get; set; }

        public double MeshDensity { get; set; }

        public SurfaceType PyMolSurfaceType { get; set; }
        public string PyMolPDBId { get; set; }
        public PyMolSpectrumPalette PyMolChargePalette { get; set; }

        public SurfaceType VMDSurfaceType { get; set; }
        public string VMDPDBId { get; set; }

        public SurfaceType ChimeraSurfaceType { get; set; }
        public string ChimeraPDBId { get; set; }

    }
    
    class TunnelsExporter
    {
        static Vector3D[] boxPoints = new Vector3D[]
        {
            new Vector3D(-1, -1, -1),
            new Vector3D(1, -1, -1),
            new Vector3D(1, 1, -1),
            new Vector3D(-1, 1, -1),
            new Vector3D(-1, -1, 1),
            new Vector3D(1, -1, 1),
            new Vector3D(1, 1, 1),
            new Vector3D(-1, 1, 1)
        };

        static int[][] boxFaces = new int[][]
        {
            new int[] { 0, 1, 2, 3 },
            new int[] { 0, 1, 3, 5 },
            new int[] { 1, 2, 5, 6 },
            new int[] { 2, 3, 7, 6 },
            new int[] { 3, 0, 4, 7 },
            new int[] { 4, 5, 6, 7 }
        };

        static readonly string[] PyMolHeader = new string[] 
        { 
            "To run this script use the 'File -> Run...' option in PyMol.",
            "",
            "This file was generated by MOLE 2 (http://mole.chemi.muni.cz, http://mole.upol.cz - moleOnline, version " +  Complex.Version + ")",
            "Please cite the following reference when reporting the results using MOLE:",
            "",
            "Sehnal D., Svobodova Varekova R., Berka K., Pravda L., Navratilova V., Banas P., Ionescu C.-M., Geidl S., Otyepka M., Koca J.:",
            "MOLE 2.0: Advanced Approach for Analysis of Biomacromolecular Channels. Journal of Cheminformatics 2013, 5:39. doi:10.1186/1758-2946-5-39",
            "",
            "and",
            "",
            "Berka, K; Hanak, O; Sehnal, D; Banas, P; Navratilova, V; Jaiswal, D; Ionescu, C-M; Svobodova Varekova, R; Koca, J; Otyepka M:",
            "MOLEonline 2.0: Interactive Web-based Analysis of Biomacromolecular Channels. Nucleic Acid Research 2012. doi:10.1093/nar/GKS363",
            ""  
        };

        static readonly string[] PdbRemarks = new string[]
        {
            "REMARK 920   ",
            string.Format("REMARK 920  This file was generated by MOLE 2 (http://mole.upol.cz, http://mole.chemi.muni.cz, version {0})", Complex.Version),
            "REMARK 920   ",
            "REMARK 920  Please cite the following references when reporting the results using MOLE:",
            "REMARK 920   ",            
            "REMARK 920  Sehnal D., Svobodova Varekova R., Berka K., Pravda L., Navratilova V., Banas P., Ionescu C.-M., Geidl S., Otyepka M., Koca J.:",
            "REMARK 920  MOLE 2.0: Advanced Approach for Analysis of Biomacromolecular Channels. Journal of Cheminformatics 2013, 5:39. doi:10.1186/1758-2946-5-39",
            "REMARK 920   ",    
            "REMARK 920  and ",    
            "REMARK 920   ",
            "REMARK 920  Berka, K; Hanak, O; Sehnal, D; Banas, P; Navratilova, V; Jaiswal, D; Ionescu, C-M; Svobodova Varekova, R; Koca, J; Otyepka M:",
            "REMARK 920  MOLEonline 2.0: Interactive Web-based Analysis of Biomacromolecular Channels. Nucleic Acid Research, 2012, doi:10.1093/nar/GKS363",
            "REMARK 920   ",
            "REMARK ATOM  NAM RES   TUNID     X       Y       Z    Distnm RadiusA "
        };

        TunnelsConfig Config;
        TunnelsComputation Computation;

        string MeshPath { get { return Path.Combine(Config.WorkingDirectory, "mesh"); } }
        string CsvPath { get { return Path.Combine(Config.WorkingDirectory, "csv"); } }
        string PdbProfilePath { get { return Path.Combine(Config.WorkingDirectory, "pdb", "profile"); } }
        string PdbStructurePath { get { return Path.Combine(Config.WorkingDirectory, "pdb", "structure"); } }
        string XmlPath { get { return Path.Combine(Config.WorkingDirectory, "xml"); } }
        string JsonPath { get { return Path.Combine(Config.WorkingDirectory, "json"); } }
        string PymolPath { get { return Path.Combine(Config.WorkingDirectory, "pymol"); } }
        string ChimeraPath { get { return Path.Combine(Config.WorkingDirectory, "chimera"); } }
        string VMDPath { get { return Path.Combine(Config.WorkingDirectory, "vmd"); } }
        string FieldsPath { get { return Path.Combine(Config.WorkingDirectory, "charges"); } }
        
        class ExportData
        {
            public Tunnel[] Tunnels { get; set; }
            public Tunnel[] MergedPores { get; set; }
            public Tunnel[] Pores { get; set; }
            public Tunnel[] Paths { get; set; }
        }

        string GetFieldsPath(string name)
        {
            return Path.Combine(FieldsPath, name);
        }

        string GetPathAndEnsureExits(params string[] path)
        {
            var dir = Path.Combine(path);
            if (!Directory.Exists(dir)) Directory.CreateDirectory(dir);
            return dir;
        }

        void ExportCharges(ExportData data, string name)
        {
            ////////////////////////////////////////////////////////////
            // XML + CSV

            ExportTunnels(data.Tunnels, "tunnels.xml", "Tunnels", charges: name);
            ExportTunnels(data.Pores, "pores.xml", "Pores", charges: name);
            ExportTunnels(data.MergedPores, "pores_merged.xml", "MergedPores", charges: name);
            ExportTunnels(data.Paths, "paths.xml", "Paths", charges: name);

            ////////////////////////////////////////////////////////////
            // PyMol

            var allChannels = new[] { data.Tunnels, data.Paths, data.MergedPores, data.Pores }
                .SelectMany(xs => xs)
                .ToArray();

            var centerlineDataPoints = allChannels
                .SelectMany(t => t.ScalarFields[name].GetValues(t.Profile).Select(n => n.Value))
                .ToArray();

            var centerlineRange = ExportColoringUtils.GetTwoSigmaRange(centerlineDataPoints);

            var surfaceDataPoints = allChannels
                .SelectMany(t => t.ScalarFields[name].Surface.Values.Where(v => v.HasValue).Select(v => v.Value))
                .ToArray();

            var surfaceRange = ExportColoringUtils.GetTwoSigmaRange(surfaceDataPoints);

            double? 
                min = surfaceRange.Item1, 
                max = surfaceRange.Item2, 
                cmin = centerlineRange.Item1, 
                cmax = centerlineRange.Item2;

            double? actMin = null, actMax = null, actCmin = null, actCmax = null;;

            allChannels.ForEach(t =>
            {
                var f = t.ScalarFields[name];
                actMin = actMin.HasValue ? Math.Min(actMin.Value, f.Surface.MinMagnitude) : f.Surface.MinMagnitude;
                actMax = actMax.HasValue ? Math.Max(actMax.Value, f.Surface.MaxMagnitude) : f.Surface.MaxMagnitude;
                actCmin = actCmin.HasValue ? Math.Min(actCmin.Value, f.CenterlineMinValue) : f.CenterlineMinValue;
                actCmax = actCmax.HasValue ? Math.Max(actCmax.Value, f.CenterlineMaxValue) : f.CenterlineMaxValue;
            });

            // surface
            var specInfo = new ExportSpectrumInfo
            {
                DisplayedMin = min,
                DisplayedMax = max,
                ActualMin = actMin,
                ActualMax = actMax
            };

            var w = new StringWriter();
            var exp = new PyMolExporter(w, header: PyMolHeader)
                .AddFields(data.Tunnels, name, min, max, Config.Export.Parameters.PyMolChargePalette)
                .AddFields(data.Paths, name, min, max, Config.Export.Parameters.PyMolChargePalette)
                .AddFields(data.MergedPores, name, min, max, Config.Export.Parameters.PyMolChargePalette)
                .AddFields(data.Pores, name, min, max, Config.Export.Parameters.PyMolChargePalette)
                .AddSurfaceSpectrum(specInfo);
            if (!string.IsNullOrEmpty(Config.Export.Parameters.PyMolPDBId))
            {
                exp.AddFetch(Config.Export.Parameters.PyMolPDBId);
            }
            File.WriteAllText(Path.Combine(GetPathAndEnsureExits(GetFieldsPath(name), "pymol"), "surface.py"), w.ToString());

            // centerline
            specInfo = new ExportSpectrumInfo
            {
                DisplayedMin = cmin,
                DisplayedMax = cmax,
                ActualMin = actCmin,
                ActualMax = actCmax
            };
            w = new StringWriter();
            exp = new PyMolExporter(w, header: PyMolHeader)
                .AddCenterlineChargeTunnels(data.Tunnels, name, cmin, cmax, Config.Export.Parameters.PyMolChargePalette, Config.Export.Parameters.PyMolSurfaceType)
                .AddCenterlineChargeTunnels(data.Paths, name, cmin, cmax, Config.Export.Parameters.PyMolChargePalette, Config.Export.Parameters.PyMolSurfaceType)
                .AddCenterlineChargeTunnels(data.MergedPores, name, cmin, cmax, Config.Export.Parameters.PyMolChargePalette, Config.Export.Parameters.PyMolSurfaceType)
                .AddCenterlineChargeTunnels(data.Pores, name, cmin, cmax, Config.Export.Parameters.PyMolChargePalette, Config.Export.Parameters.PyMolSurfaceType)
                .AddCenterlineSpectrum(specInfo);
            if (!string.IsNullOrEmpty(Config.Export.Parameters.PyMolPDBId))
            {
                exp.AddFetch(Config.Export.Parameters.PyMolPDBId);
            }
            File.WriteAllText(Path.Combine(GetPathAndEnsureExits(GetFieldsPath(name), "pymol"), "centerline.py"), w.ToString());
        }

        void WriteStructure(Tunnel t, string filename)
        {
            var atoms = t.Lining.SelectMany(r => r.Atoms).OrderBy(a => a.Id);
            using (var file = File.CreateText(filename))
            {
                PdbRemarks.Take(PdbRemarks.Length - 2).ForEach(r => file.WriteLine(r));
                foreach (var a in atoms) file.WriteLine(StructureWriter.GetPdbAtomRecord(a));
            }
        }

        void ExportInternal()
        {
            ////////////////////////////////////////////////////////////
            // JSON

            if (Config.Export.Parameters.FormatJSON)
            {
                ExportJson(Path.Combine(JsonPath, "data.json"));
            }

            ////////////////////////////////////////////////////////////
            // XML

            var data = new ExportData
            {
                Tunnels = Computation.Complex.Tunnels.OrderBy(t => 10000 - t.StartPoint.Type).ThenBy(t => t.Id).ToArray(),
                MergedPores = Computation.Complex.Pores.Where(p => p.IsMergedPore).ToArray(),
                Pores = Computation.Complex.Pores.Where(p => !p.IsMergedPore).ToArray(),
                Paths = Computation.Complex.Paths.ToArray()
            };

            ExportTunnels(data.Tunnels, "tunnels.xml", "Tunnels");
            ExportTunnels(data.Pores, "pores.xml", "Pores");
            ExportTunnels(data.MergedPores, "pores_merged.xml", "MergedPores");
            ExportTunnels(data.Paths, "paths.xml", "Paths");

            ExportTunnelsCSV(data.Tunnels, "tunnels.csv");
            ExportTunnelsCSV(data.Pores, "pores.csv");
            ExportTunnelsCSV(data.MergedPores, "merged_pores.csv");
            ExportTunnelsCSV(data.Paths, "paths.csv");

            var xCavities = new XElement("Cavities", new XAttribute("Version", Complex.Version));
            foreach (var cavity in Computation.Complex.Cavities) xCavities.Add(cavity.ToXml());
            foreach (var cavity in Computation.Complex.Voids) xCavities.Add(cavity.ToXml());
            xCavities.Add(Computation.Complex.SurfaceCavity.ToXml());
            using (var w = XmlWriter.Create(Path.Combine(XmlPath, "cavities.xml"), new XmlWriterSettings() { Indent = true }))
            {
                xCavities.WriteTo(w);
            }

            var startPointsNode = new XElement("StartPoints");
            Computation.Complex.TunnelOrigins
                .Select(o => new XElement("StartPoint",
                    new XAttribute("Type", o.Type),
                    new XAttribute("Id", o.Id),
                    new XAttribute("CavityId", o.Cavity.Id),
                    new XAttribute("Depth", o.Tetrahedron.Depth),
                    new XAttribute("X", o.Tetrahedron.Center.X.ToString("0.000", CultureInfo.InvariantCulture)),
                    new XAttribute("Y", o.Tetrahedron.Center.Y.ToString("0.000", CultureInfo.InvariantCulture)),
                    new XAttribute("Z", o.Tetrahedron.Center.Z.ToString("0.000", CultureInfo.InvariantCulture)),
                    ExportStartPointsMeshString(new Vector3D[] { o.Tetrahedron.Center })))
                .ForEach(o => startPointsNode.Add(o));

            using (var w = XmlWriter.Create(Path.Combine(XmlPath, "startpoints.xml"), new XmlWriterSettings() { Indent = true }))
            {
                startPointsNode.WriteTo(w);
            }

            //////////////////////////////////////////////////////////////
            // PyMol and VMD and Chimera
            bool exportMergedPores = Config.Export.Parameters.ExportMergedPores;
            bool exportPores = Config.Export.Parameters.ExportAutoPores || Config.Export.Parameters.ExportUserPores;

            if (Config.Export.Parameters.FormatPyMol)
            {
                {
                    var w = new StringWriter();
                    var exp = new PyMolExporter(w, header: PyMolHeader);
                    exp.AddTunnels(data.Tunnels, Config.Export.Parameters.PyMolSurfaceType);
                    exp.AddTunnels(data.Paths, Config.Export.Parameters.PyMolSurfaceType);
                    exp.AddTunnels(data.MergedPores, Config.Export.Parameters.PyMolSurfaceType);
                    exp.AddTunnels(data.Pores, Config.Export.Parameters.PyMolSurfaceType);
                    exp.AddCavities("Interior", Computation.Complex.Cavities);
                    exp.AddStructure(Path.GetFileName(Config.Input.Filename));
                    if (!string.IsNullOrEmpty(Config.Export.Parameters.PyMolPDBId))
                    {
                        exp.AddFetch(Config.Export.Parameters.PyMolPDBId);
                    }
                    File.WriteAllText(Path.Combine(PymolPath, "complex.py"), w.ToString());
                }
            }

            if (Config.Export.Parameters.FormatVMD)
            {
                {
                    var w = new StringWriter();
                    var exp = new VmdExporter(w);
                    exp.AddTunnels(data.Tunnels, "", Config.Export.Parameters.VMDSurfaceType);
                    exp.AddTunnels(data.Paths, "", Config.Export.Parameters.VMDSurfaceType);
                    exp.AddTunnels(data.MergedPores, "", Config.Export.Parameters.VMDSurfaceType);
                    exp.AddTunnels(data.Pores, "", Config.Export.Parameters.VMDSurfaceType);
                    exp.AddCavities("Interior", Computation.Complex.Cavities);

                    if (!string.IsNullOrEmpty(Config.Export.Parameters.VMDPDBId))
                    {
                        exp.AddFetch(Config.Export.Parameters.VMDPDBId);
                    }
                    File.WriteAllText(Path.Combine(VMDPath, "complex"), w.ToString());
                }
            }

            if (Config.Export.Parameters.FormatChimera)
            {
                {
                    var w = new StringWriter();
                    var exp = new ChimeraExporter(w);
                    exp.AddTunnels(data.Tunnels, Config.Export.Parameters.ChimeraSurfaceType);
                    exp.AddTunnels(data.Paths, Config.Export.Parameters.ChimeraSurfaceType);
                    exp.AddTunnels(data.MergedPores, Config.Export.Parameters.ChimeraSurfaceType);
                    exp.AddTunnels(data.Pores, Config.Export.Parameters.ChimeraSurfaceType);
                    exp.AddCavities("Interior", Computation.Complex.Cavities);

                    if (!string.IsNullOrEmpty(Config.Export.Parameters.ChimeraPDBId))
                    {
                        exp.AddFetch(Config.Export.Parameters.ChimeraPDBId);
                    }
                    File.WriteAllText(Path.Combine(ChimeraPath, "complex.py"), w.ToString());
                }
            }

            //////////////////////////////////////////////////////////////
            // PDB
            if (Config.Export.Parameters.FormatPdbProfile)
            {
                using (var file = File.CreateText(Path.Combine(PdbProfilePath, "tunnels.pdb")))
                {
                    new TunnelPdbExporter(file, WebChemistry.Framework.Core.Structure.Empty, remarks: PdbRemarks).WriteTunnels(data.Tunnels);
                }

                if (data.Paths.Length > 0)
                {
                    using (var file = File.CreateText(Path.Combine(PdbProfilePath, "paths.pdb")))
                    {
                        new TunnelPdbExporter(file, WebChemistry.Framework.Core.Structure.Empty, remarks: PdbRemarks).WriteTunnels(data.Paths);
                    }
                }

                if (exportPores && data.Pores.Length > 0)
                {
                    using (var file = File.CreateText(Path.Combine(PdbProfilePath, "pores.pdb")))
                    {
                        new TunnelPdbExporter(file, WebChemistry.Framework.Core.Structure.Empty, remarks: PdbRemarks).WriteTunnels(data.Pores);
                    }
                }

                if (exportMergedPores && data.MergedPores.Length > 0)
                {
                    using (var file = File.CreateText(Path.Combine(PdbProfilePath, "pores_merged.pdb")))
                    {
                        new TunnelPdbExporter(file, WebChemistry.Framework.Core.Structure.Empty, remarks: PdbRemarks).WriteTunnels(data.MergedPores);
                    }
                }
            }
            
            //////////////////////////////////////////////////////////////
            // Meshes

            if (Config.Export.Parameters.ExportCavities)
            {
                string filename = Path.Combine(MeshPath, "surface.mesh");
                ExportCavityMesh(filename, Computation.Complex.SurfaceCavity);

                Computation.Complex.Cavities.ForEach((c, i) =>
                {
                    filename = Path.Combine(MeshPath, "cavity_" + (i + 1) + ".mesh");
                    ExportCavityMesh(filename, c);
                });

                Computation.Complex.Voids.ForEach((c, i) =>
                {
                    filename = Path.Combine(MeshPath, "void_" + (i + 1) + ".mesh");
                    ExportCavityMesh(filename, c);
                });
            }
            
            ExportStartPointsMesh(Path.Combine(MeshPath, "startpoints.mesh"), Computation.Complex, TunnelOriginType.User);
            ExportStartPointsMesh(Path.Combine(MeshPath, "autostartpoints.mesh"), Computation.Complex, TunnelOriginType.Computed);
            ExportStartPointsMesh(Path.Combine(MeshPath, "customexits.mesh"), Computation.FoundCustomExitPoints);

            ExportStartPointsMesh(Path.Combine(MeshPath, "invariantstartpoint.mesh"), Computation.OriginPoints);
            ExportStartPointsMesh(Path.Combine(MeshPath, "invariantcustomexits.mesh"), Computation.CustomExitPoints);

            //////////////////////////////////////////////////////////////
            // Charges

            foreach (var f in Computation.Complex.ScalarFields)
            {
                ExportCharges(data, f.Name);
            }
        }

        private void ExportTunnelsCSV(Tunnel[] tunnels, string v)
        {
            if (tunnels.Count() == 0) return;

            using (var csv = File.CreateText(Path.Combine(CsvPath , v)))
            {
                csv.WriteLine("Id,Length,Charge,Ionizable,Hydropathy,Hydrophobicity,Polarity,LogP,LogD,LogS,Mutability");
                foreach (var item in tunnels)
                {
                    csv.WriteLine("T{0}C{1},{2},{3},{4},{5},{6},{7},{8},{9},{10},{11}", item.Id, item.Cavity.Id, item.Length.ToString("0.00"),
                        item.LayerWeightedPhysicoChemicalProperties.Charge,
                        item.LayerWeightedPhysicoChemicalProperties.Ionizable,
                        item.LayerWeightedPhysicoChemicalProperties.Hydropathy.ToString("0.00"),
                        item.LayerWeightedPhysicoChemicalProperties.Hydrophobicity.ToString("0.00"),
                        item.LayerWeightedPhysicoChemicalProperties.Polarity.ToString("0.00"),
                        item.LayerWeightedPhysicoChemicalProperties.LogP.ToString("0.00"),
                        item.LayerWeightedPhysicoChemicalProperties.LogD.ToString("0.00"),
                        item.LayerWeightedPhysicoChemicalProperties.LogS.ToString("0.00"),
                        item.LayerWeightedPhysicoChemicalProperties.Mutability.ToString("0.00"));
                }
            }
        }

        static object JsonFormatOrigins(IEnumerable<Vector3D> xs, string type)
        {
            return new { Type = type, Points = xs.Select(x => new { X = Math.Round(x.X, 2), Y = Math.Round(x.Y, 2), Z = Math.Round(x.Z, 2) }) };
        }

        void ExportJson(string filename)
        {
            var origins = Computation.Complex.TunnelOrigins.GroupBy(o => o.Type).ToDictionary(g => g.Key, g => g.Select(o => o.ToJson()).ToArray());
            
            var data = new
            {
                Version = Complex.Version,
                Config = Config,
                FoundOrigin = Computation.Complex.TunnelOrigins.OfType(TunnelOriginType.User).Count() > 0,
                Timing = Computation.Timer.ElapsedMilliseconds,
                Channels = new
                {
                    Tunnels = ExportTunnelsToJson(Computation.Complex.Tunnels.OrderBy(t => 10000 - t.StartPoint.Type).ThenBy(t => t.Id).ToArray()),
                    MergedPores = ExportTunnelsToJson(Computation.Complex.Pores.Where(p => p.IsMergedPore).ToArray()),
                    Pores = ExportTunnelsToJson(Computation.Complex.Pores.Where(p => !p.IsMergedPore).ToArray()),
                    Paths = ExportTunnelsToJson(Computation.Complex.Paths.ToArray())
                },
                Cavities = new {
                    Cavities = Computation.Complex.Cavities.Select(c => c.ToJson()).ToArray(),
                    Voids = Computation.Complex.Voids.Select(c => c.ToJson()).ToArray(),
                    Surface = Computation.Complex.SurfaceCavity.ToJson()
                },
                Origins = new
                {
                    User = new { Type = "User", Points = origins.ContainsKey(TunnelOriginType.User) ? origins[TunnelOriginType.User] : new object[0] },
                    Computed = new { Type = "Computed", Points = origins.ContainsKey(TunnelOriginType.Computed) ? origins[TunnelOriginType.Computed] : new object[0] },
                    Database = new { Type = "Database", Points = origins.ContainsKey(TunnelOriginType.Database) ? origins[TunnelOriginType.Database] : new object[0] },

                    InputOrigins = JsonFormatOrigins(Computation.OriginPoints, "InputOrigin"),
                    InputExits = JsonFormatOrigins(Computation.OriginPoints, "InputExit"),
                    InputFoundExits = JsonFormatOrigins(Computation.FoundCustomExitPoints, "InputFoundExit")
                }

            };
            
            File.WriteAllText(filename, data.ToJsonString(false));
            using (var gzf = File.Create(filename + ".gz"))
            {
                using (var gz = new GZipStream(gzf, CompressionMode.Compress))
                {
                    using (var f = File.OpenRead(filename))
                    {
                        f.CopyTo(gz);
                    }
                }
            }
        }

        object ExportTunnelsToJson(IEnumerable<Tunnel> tunnels)
        {
            return tunnels.Select((t, i) => t.ToJson(/*Config.Export.Parameters.MeshDensity, */customId: i)).ToArray();
        }

        void ExportTunnels(IEnumerable<Tunnel> tunnels, string xmlFilename, string header, string charges = null)
        {
            var xTunnels = new XElement(header,
                new XAttribute("Version", Complex.Version),
                new XAttribute("FoundOrigin", Computation.Complex.TunnelOrigins.OfType(TunnelOriginType.User).Count() > 0 ? "1" : "0"),
                new XAttribute("Timing", Computation.Timer.ElapsedMilliseconds));
            int counter = 1;
            foreach (var t in tunnels)
            {
                if (charges != null) xTunnels.Add(ExportTunnelWithCharges(counter, t, charges));
                else xTunnels.Add(ExportTunnel(counter, t));
                counter++;
            }
            string path = charges == null ? XmlPath : GetPathAndEnsureExits(GetFieldsPath(charges), "xml");
            using (var w = XmlWriter.Create(Path.Combine(path, xmlFilename), new XmlWriterSettings() { Indent = true }))
            {
                xTunnels.WriteTo(w);
            }
        }

        XElement ExportTunnelWithCharges(int index, Tunnel tunnel, string charges)
        {
            var name = tunnel.Type.ToString();

            string filePrefix = name.ToLower() + "_";

            var profileNode = new XElement("Profile");
            var ctp = tunnel.Profile;

            if (Config.Export.Parameters.FormatCSV)
            {
                var charge = tunnel.ScalarFields[charges].GetValues(ctp);
                var path = GetPathAndEnsureExits(GetFieldsPath(charges), "csv");
                using (var csv = File.CreateText(Path.Combine(path, filePrefix + index + ".csv")))
                {
                    ctp.CreateExporter(",")
                        .AddExportableColumn(n => charge[n].ToStringInvariant("0.000"), Framework.Core.ColumnType.Number, "Charge")
                        .WriteCsvString(csv);
                }
            }

            if (Config.Export.Parameters.FormatChargeSurface)
            {
                var vs = new XElement("Vertices");
                var tris = new XElement("Triangles");
                var field = tunnel.ScalarFields[charges];
                var vert = field.Surface.Surface.Vertices;
                var values = field.Surface.Values;

                for (int i = 0; i < vert.Length; i++)
                {
                    var v = vert[i];
                    var val = values[i];
                    vs.Add(new XElement("Vertex",
                        new XAttribute("Id", v.Id),
                        new XAttribute("X", v.Position.X.ToStringInvariant("0.000")),
                        new XAttribute("Y", v.Position.Y.ToStringInvariant("0.000")),
                        new XAttribute("Z", v.Position.Z.ToStringInvariant("0.000")),
                        new XAttribute("Value", val != null ? val.Value.ToStringInvariant("0.000") : "-")));
                }

                foreach (var t in field.Surface.Surface.Triangles)
                {
                    tris.Add(new XElement("Triangle",
                        new XAttribute("A", t.A.Id),
                        new XAttribute("B", t.B.Id),
                        new XAttribute("C", t.C.Id)));
                }

                var xml = new XElement("Surface", new XAttribute("TotalValue", field.Total.ToStringInvariant("0.000")), vs, tris);
                var path = GetPathAndEnsureExits(GetFieldsPath(charges), "xml");
                using (var w = XmlWriter.Create(Path.Combine(path, filePrefix + index + "_surface.xml"), new XmlWriterSettings() { Indent = true }))
                {
                    xml.WriteTo(w);
                }
            }

            return tunnel.ToXml(customId: index, includeCharge: charges);
        }

        XElement ExportTunnel(int index, Tunnel tunnel)
        {
            var name = tunnel.Type == TunnelType.Pore && tunnel.IsMergedPore ? "MergedPore" : tunnel.Type.ToString();

            string filePrefix = name.ToLower() + "_"; 

            var profileNode = new XElement("Profile");
            var ctp = tunnel.Profile;
            
            if (Config.Export.Parameters.FormatPdbProfile)
            {
                using (var pdb = File.CreateText(Path.Combine(PdbProfilePath, filePrefix + index + ".pdb")))
                {
                    new TunnelPdbExporter(pdb, Computation.Structure, remarks: PdbRemarks).WriteTunnel(tunnel);
                }
            }

            if (Config.Export.Parameters.FormatPdbStructure)
            {
                WriteStructure(tunnel, Path.Combine(PdbStructurePath, filePrefix + index + ".pdb"));
            }

            if (Config.Export.Parameters.FormatCSV)
            {
                using (var csv = File.CreateText(Path.Combine(CsvPath, filePrefix + index + ".csv")))
                {
                    ctp.CreateExporter(",").WriteCsvString(csv);
                }

                using (var csv = File.CreateText(Path.Combine(CsvPath, filePrefix + index + "_physchem.csv")))
                {
                    csv.WriteLine(tunnel.GetLiningLayers().ToCsvString());
                }
            }

            if (Config.Export.Parameters.FormatMesh || Config.Export.Parameters.FormatMeshGz)
            {
                var iso = tunnel.GetSurface(Config.Export.Parameters.MeshDensity); //IsoSurface.Create(tunnel, Config.Export.Parameters.MeshDensity);
                
                var filename = Path.Combine(MeshPath, filePrefix + index + ".mesh");

                using (var meshStream = new MemoryStream())
                {
                    using (var w = new StreamWriter(meshStream))
                    {
                        iso.WriteMesh(w);
                        w.Flush();

                        if (Config.Export.Parameters.FormatMesh)
                        {
                            using (var f = File.Create(filename))
                            {
                                meshStream.Seek(0L, SeekOrigin.Begin);
                                meshStream.CopyTo(f);
                            }
                        }

                        if (Config.Export.Parameters.FormatMeshGz)
                        {
                            using (var gzf = File.Create(filename + ".gz"))
                            {
                                using (var gz = new GZipStream(gzf, CompressionMode.Compress))
                                {
                                    meshStream.Seek(0L, SeekOrigin.Begin);
                                    meshStream.CopyTo(gz);
                                }
                            }
                        }
                    }
                }
            }

            return tunnel.ToXml(customId: index);
        }

        void ExportStartPointsMesh(string filename, Complex complex, TunnelOriginType type)
        {
            Func<TunnelOrigin, Vector3D[]> getBox = o => boxPoints.Select(p => 1.0 * p + o.Tetrahedron.Center).ToArray();
            ExportStartPointsMesh(filename, complex.TunnelOrigins.OfType(type).Select(o => o.Tetrahedron.Center).ToList());
        }

        static string ExportStartPointsMeshString(IEnumerable<Vector3D> positions)
        {
            Func<Vector3D, Vector3D[]> getBox = o => boxPoints.Select(p => 1.0 * p + o).ToArray();

            var boxes = positions.Select(o => getBox(o)).ToArray();

            StringBuilder w = new StringBuilder();

            var vertexCount = boxes.Length * 8;
            w.AppendLine(vertexCount.ToString());

            foreach (var v in boxes.SelectMany(b => b))
            {
                w.AppendLine(string.Format(CultureInfo.InvariantCulture, "{0:0.000000} {1:0.000000} {2:0.000000}", v.X, v.Y, v.Z));
            }

            w.AppendLine((boxes.Length * 6).ToString());
            boxes.ForEach((b, i) =>
            {
                var offset = i * 8;
                boxFaces.ForEach(f =>
                {
                    w.AppendLine("5");
                    w.AppendLine((f[0] + offset).ToString());
                    w.AppendLine((f[1] + offset).ToString());
                    w.AppendLine((f[2] + offset).ToString());
                    w.AppendLine((f[3] + offset).ToString());
                    w.AppendLine((f[0] + offset).ToString());
                });
            });

            return w.ToString();
        }

        void ExportStartPointsMesh(string filename, IEnumerable<Vector3D> positions)
        {
            using (var meshStream = new MemoryStream())
            {
                using (var w = new StreamWriter(meshStream))
                {
                    w.Write(ExportStartPointsMeshString(positions));

                    w.Flush();

                    if (Config.Export.Parameters.FormatMesh)
                    {
                        using (var f = File.Create(filename))
                        {
                            meshStream.Seek(0L, SeekOrigin.Begin);
                            meshStream.CopyTo(f);
                        }
                    }

                    if (Config.Export.Parameters.FormatMeshGz)
                    {
                        using (var gzf = File.Create(filename + ".gz"))
                        {
                            using (var gz = new GZipStream(gzf, CompressionMode.Compress))
                            {
                                meshStream.Seek(0L, SeekOrigin.Begin);
                                meshStream.CopyTo(gz);
                            }
                        }
                    }
                }
            }
        }

        void ExportCavityMesh(string filename, Cavity cavity)
        {
            using (var meshStream = new MemoryStream())
            {
                using (var w = new StreamWriter(meshStream))
                {
                    Dictionary<Vertex, int> vertexIndex = new Dictionary<Vertex, int>();
                    var vertices = cavity.Boundary.SelectMany(f => f.Vertices).Distinct().ToArray();
                    vertices.ForEach((v, i) => vertexIndex.Add(v, i));

                    var vertexCount = vertices.Length;
                    w.WriteLine(vertexCount);

                    foreach (var v in vertices)
                    {
                        w.WriteLine(string.Format(CultureInfo.InvariantCulture, "{0:0.000000} {1:0.000000} {2:0.000000}",
                             v.Position.X, v.Position.Y, v.Position.Z));
                    }

                    w.WriteLine(cavity.Boundary.Count());
                    foreach (var t in cavity.Boundary)
                    {
                        w.WriteLine(4);
                        w.WriteLine(vertexIndex[t.Vertices[0]]);
                        w.WriteLine(vertexIndex[t.Vertices[1]]);
                        w.WriteLine(vertexIndex[t.Vertices[2]]);
                        w.WriteLine(vertexIndex[t.Vertices[0]]);
                    }

                    w.Flush();

                    if (Config.Export.Parameters.FormatMesh)
                    {
                        using (var f = File.Create(filename))
                        {
                            meshStream.Seek(0L, SeekOrigin.Begin);
                            meshStream.CopyTo(f);
                        }
                    }

                    if (Config.Export.Parameters.FormatMeshGz)
                    {
                        using (var gzf = File.Create(filename + ".gz"))
                        {
                            using (var gz = new GZipStream(gzf, CompressionMode.Compress))
                            {
                                meshStream.Seek(0L, SeekOrigin.Begin);
                                meshStream.CopyTo(gz);
                            }
                        }
                    }
                }
            }
        }

        void WriteOutputError(string message)
        {
            var root = new XElement("Tunnels", new XAttribute("Version", Complex.Version));
            root.Add(new XElement("Exception", new XAttribute("Text", message)));

            using (var w = XmlWriter.Create(Path.Combine(XmlPath, "tunnels.xml"), new XmlWriterSettings() { Indent = true }))
            {
                root.WriteTo(w);
            }
        }

        public void Export()
        {
            Console.WriteLine("Exporting...");  

            try
            {
                if (!Directory.Exists(Config.WorkingDirectory)) Directory.CreateDirectory(Config.WorkingDirectory);

                if (Config.Export.Parameters.FormatMesh || Config.Export.Parameters.FormatMeshGz)
                {
                    if (!Directory.Exists(MeshPath)) Directory.CreateDirectory(MeshPath);
                }

                if (Config.Export.Parameters.FormatCSV)
                {
                    if (!Directory.Exists(CsvPath)) Directory.CreateDirectory(CsvPath);
                }

                if (!Directory.Exists(XmlPath)) Directory.CreateDirectory(XmlPath);

                if (Config.Export.Parameters.FormatJSON)
                {
                    if (!Directory.Exists(JsonPath)) Directory.CreateDirectory(JsonPath);
                }

                if (Config.Export.Parameters.FormatPdbProfile)
                {
                    if (!Directory.Exists(PdbProfilePath)) Directory.CreateDirectory(PdbProfilePath);
                }
                if (Config.Export.Parameters.FormatPdbStructure)
                {
                    if (!Directory.Exists(PdbStructurePath)) Directory.CreateDirectory(PdbStructurePath);
                }
                
                if (Config.Export.Parameters.FormatPyMol)
                {
                    if (!Directory.Exists(PymolPath)) Directory.CreateDirectory(PymolPath);
                }

                if (Config.Export.Parameters.FormatVMD)
                {
                    if (!Directory.Exists(VMDPath)) Directory.CreateDirectory(VMDPath);
                }

                if (Config.Export.Parameters.FormatChimera)
                {
                    if (!Directory.Exists(ChimeraPath)) Directory.CreateDirectory(ChimeraPath);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine("Error creating working directory: {0}", e.Message);
                throw e;
            }

            if (Computation.HasError)
            {
                Console.WriteLine("Error: ");
                Console.WriteLine(Computation.ErrorMessage);
                WriteOutputError(Computation.ErrorMessage);
            }
            
            try
            {
                ExportInternal();
            }
            catch (Exception e)
            {
                WriteOutputError(e.Message);
                throw e;
            }
        }

        public TunnelsExporter(TunnelsConfig config, TunnelsComputation computation)
        {
            this.Config = config;
            this.Computation = computation;
        }
    }
}
